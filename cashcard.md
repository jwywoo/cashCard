## 20230209
## Spring Boot : Introduction to RESTful web service

Building an web app that handles allowance of user's kids
1. Creating a single cash card in a DB
2. Allowing user to editing, deleting and viewing of multiple cash cards
3. Deploying and monitoring the app in the cloud

Further more, there will be explanations about RESTful API including benefits and tradeoffs

Spring's Inversion of Control Container
Also know as IoC(Inversion of Control) Container or DI(dependency injection)

Spring allows you to configure how and when dependencies are use or 'injected' into the app at runtime

### Spring Initializer
url: `start.spring.io`
#### Project: Gradle - groovy
#### Language: Java
#### Spring Boot Version: 3.0x

#### Project Metadata
1. Group: com.example (or example)
2. Artifact: cashcard 
3. Name: cashCard 
4. Description: Cash Card service for fmaily cash cards 

#### Packaging: Jar
#### Java: 17

#### Dependencies: Spring Web

### How to build it
1. download the zip file generated by initializer
2. set the directory location
3. unzip it and move to the directory
```
cd cashcard
./gradlew build
```
4. Done

### JSON & Data Contracts
JSON -> Javascript Object Notation

Providing a data interchange format that represents particular information of  object -> easy to use and understand

### YAML & XML

Compare to YAML, JSON is easy to user and takes less space.
Further more, JSON works well with Javascript based application

### JSON Contract
It is a formal agreement between a service & client to communicates the data to be exchnaged
This characteristics allows server and client to use different language but have to have same contracts
This is important since it defines behavior of a REST API and provides specific details of serialized (or deserialized) for each commands and parameter being exchanged.
Also, it is understandable for both developer and REST API.

## 20230210
## Testing
### Importance of Test Driven Development(TDD)
1. By asserting expected behaviour we can build project based on what we want than what the system can do already.
2. By building test first we can implement with minimum code.

### Testing Pyramid
There are different types of test for different level of system. Cost of running it and maintaining it varies by the test.
Also, different types of test can affect correctness of tests.

To build test driven Spring Boot project. it is important to start with test file.
### Adding Test
1. Go to `src/test/java/(package directory)`
- In case of package directory there can be multiple directories
- For this project there is only one which is `com.exmple.cashcard`
2. Then type this at `CashCardApplicationTest` class
    ```
   package com.example.cashcard;
   
   import org.junit.jupiter.api.Test;
   import org.springframework.boot.test.context.SpringBootTest;
   import static org.assertj.core.api.Assertions.assertThat;
   
   @SpringBootTest 
   class CashCardApplicationTests {
       @Test
       public void myFirstTest() {
           ertThat(42).isEqualTo(1);
       }
   }
   ```
- To build Testing First Spring Boot Project it is better to start with wrong to test to check
### Build and Run Test
1. After you create your test we need to build and run the test.
2. Go to directory where `./gradelw` is
3. Then type this and run it
   ```
   ./gradlew test
   ```
4. It will build the test you created and whenever you want to test you got to do it like this.
5. However, your test is failed it won't build then you have a issue with your code, but if all test is passed it will build it.

## 20230215
### Spring Annotations & Component Scan

Spring Beans: It is an object created by Spring that is stored in IoC container. This object can be injected any code like an object in Java.

Annotations: It is one of the ways to create Spring Beans. At the runtime Spring during Component Scan Phase, Spring use this annotation to create Beans.

### How Spring Web Handles Request
All the request given to Spring Web is handled by Controller class that has `@RestController` annotation.
```
@RestController
public class CashCardController {
}
```
Further more controller class can handle different methods by creating designated functions.
To handle `GET` function should have `@GetMapping` annotation. 
```
@GetMapping("/cashcards/{requestId}")
public CashCard findById(Long requestId) {
}
```
`{requestId}` is one of url parameter that supports the function to process request.
By using `@PathVariable` annotation we can make function to use  `{reqeustId}`. But the name we use for the annotation got to be equal to the name of the parameter.

```
@GetMapping("/cashcards/{requestId}")
public CashCard findById(@PathVariable Long requestID) {
}
```

After this we need to return response since it's been requested.
If we want to send 200 response which is success we need to use `ResponseEntity` builtin function.
```
@RestController
public class CashCardRestController {
   @GetMapping("/cashcards/{requestId}")
   public ResponseEntity<CashCard> findById(@PathVariable Long requestID) {
         CashCard result = /* We are going to create a way to return matching object */
         return ResponseEntity.ok(result);
   }
}
```

#### Be aware of the changes of data type also the order of annotations

For the summary, `@RestConller` show this class handles request.

`@GetMapping` shows a function of the class handles `GET` method.

`@PathVariable` handles parameter that can be used to process the request for the function.

`ResponseEntity` returns status whether that request is well handled or not.


